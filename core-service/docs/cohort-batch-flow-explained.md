# 코호트 LTV 배치 처리 흐름 설명

## 1. 핵심 개념

### 코호트(Cohort)란?
- **정의**: 특정 캠페인에서 **처음 구매한 고객 집단**
- **예시**: 2024년 1월에 시작한 캠페인에서 첫 구매한 고객 100명 → "1월 코호트"
- **추적 목표**: 이 고객들이 시간이 지나면서 얼마나 더 구매하는가?

### Month Offset이란?
- **offset 0**: 캠페인 시작 후 첫 달 (1월 1일 ~ 1월 31일)
- **offset 1**: 캠페인 시작 후 2달째 (2월 1일 ~ 2월 28일)
- **offset 2**: 캠페인 시작 후 3달째 (3월 1일 ~ 3월 31일)
- ...
- **offset 11**: 캠페인 시작 후 12달째 (12월 1일 ~ 12월 31일)

## 2. 배치 실행 원리

### 스케줄 설정
```java
@Scheduled(cron = "0 */1 * * * ?")  // 현재: 매 1분마다 (테스트용)
// @Scheduled(cron = "0 0 3 1 * ?")  // 프로덕션: 매월 1일 새벽 3시
```

### 배치가 하는 일
```
1. 12개월 이내 시작한 모든 캠페인 활동 조회
2. 각 캠페인마다:
   - 기존 통계 테이블 확인 (어디까지 만들었나?)
   - 다음 offset 1개만 생성
   - 완료
```

## 3. 실제 동작 예시

### 시나리오: 9001번 캠페인 (2024년 1월 1일 시작)

현재 날짜: **2024년 4월 1일**

#### 배치 1차 실행 (4월 1일 00:00)

```
1. DB 확인: offset 데이터 없음
2. lastOffset = -1
3. newOffset = 0 (다음 생성할 offset)
4. 조회 범위: 1월 1일 ~ 2월 1일 (캠페인 시작일 + 0개월 ~ +1개월)
5. 계산:
   - 코호트 정의: 1월에 첫 구매한 고객 10명
   - 월별 매출: 500,000원 (1월 구매 금액)
   - 누적 LTV: 500,000원
6. INSERT: offset=0 row 생성
7. 완료 (1개만!)
```

**DB 상태**: `| offset=0 | ltv=500,000 | monthly=500,000 |`

---

#### 배치 2차 실행 (4월 1일 00:01, 1분 후)

```
1. DB 확인: offset 0 존재
2. lastOffset = 0
3. newOffset = 1 (다음 생성할 offset)
4. 조회 범위: 2월 1일 ~ 3월 1일 (캠페인 시작일 + 1개월 ~ +2개월)
5. 계산:
   - 코호트 고객: 10명 (이미 확정됨)
   - 2월 구매: 5명, 300,000원 (증분)
   - 누적 LTV: 500,000 (이전 달) + 300,000 (이번 달) = 800,000원
6. INSERT: offset=1 row 생성
7. 완료 (1개만!)
```

**DB 상태**:
```
| offset=0 | ltv=500,000 | monthly=500,000 |
| offset=1 | ltv=800,000 | monthly=300,000 |
```

---

#### 배치 3차 실행 (4월 1일 00:02, 2분 후)

```
1. DB 확인: offset 0, 1 존재
2. lastOffset = 1
3. newOffset = 2
4. 조회 범위: 3월 1일 ~ 4월 1일
5. 계산:
   - 3월 구매: 3명, 200,000원 (증분)
   - 누적 LTV: 800,000 + 200,000 = 1,000,000원
6. INSERT: offset=2 row 생성
```

**DB 상태**:
```
| offset=0 | ltv=500,000 | monthly=500,000 |
| offset=1 | ltv=800,000 | monthly=300,000 |
| offset=2 | ltv=1,000,000 | monthly=200,000 |
```

---

#### 배치 4차 실행 (4월 1일 00:03, 3분 후)

```
1. DB 확인: offset 0, 1, 2 존재
2. lastOffset = 2
3. newOffset = 3
4. 조회 범위: 4월 1일 ~ 5월 1일
5. 계산:
   - 4월 구매: 아직 없음 (막 시작), 0원
   - 누적 LTV: 1,000,000 + 0 = 1,000,000원
6. INSERT: offset=3 row 생성
```

**DB 상태**:
```
| offset=0 | ltv=500,000 | monthly=500,000 |
| offset=1 | ltv=800,000 | monthly=300,000 |
| offset=2 | ltv=1,000,000 | monthly=200,000 |
| offset=3 | ltv=1,000,000 | monthly=0 |
```

---

#### 배치 5차 실행 (4월 1일 00:04, 4분 후)

```
1. DB 확인: offset 0, 1, 2, 3 존재
2. lastOffset = 3
3. newOffset = 4
4. 조회 범위: 5월 1일 ~ 6월 1일
5. ❌ 아직 5월 안 됨! (현재 4월 1일)
6. return null (생성 안 함)
7. 완료
```

**DB 상태**: 변화 없음 (offset 3까지만)

---

## 4. 핵심 로직

### 날짜 계산 공식

```java
// offset에 해당하는 월 범위 계산
LocalDateTime monthStart = 캠페인시작일.plusMonths(offset);
LocalDateTime monthEnd = 캠페인시작일.plusMonths(offset + 1);

// 예: 캠페인 1월 1일 시작, offset=2
monthStart = 1월 1일 + 2개월 = 3월 1일
monthEnd = 1월 1일 + 3개월 = 4월 1일
→ 조회 범위: 3월 1일 ~ 4월 1일
```

### 증분 업데이트

```java
if (offset == 0) {
    // 첫 달: 전체 계산
    ltvCumulative = 해당 월 매출 합계
} else {
    // 2달 이후: 이전 달 누적 + 이번 달 증분
    ltvCumulative = 이전달.ltvCumulative + 이번달.monthlyRevenue
}
```

### 생성 조건

```java
// 1. 12개월 제한
if (newOffset >= 12) return null;

// 2. 아직 도래하지 않은 월
if (cohortStartDate.plusMonths(newOffset + 1).isAfter(현재시간)) {
    return null;  // 해당 월이 아직 안 됨
}

// 3. 코호트 고객이 없음
if (firstPurchases.isEmpty()) return null;
```

## 5. 프로덕션 환경 시나리오

### 실제 운영 (매월 1일 새벽 3시 실행)

**2024년 1월 1일**: 캠페인 시작, 고객 구매 발생
**2024년 2월 1일 03:00**: 배치 실행 → offset 0 생성 (1월 데이터)
**2024년 3월 1일 03:00**: 배치 실행 → offset 1 생성 (2월 데이터)
**2024년 4월 1일 03:00**: 배치 실행 → offset 2 생성 (3월 데이터)
...
**2025년 1월 1일 03:00**: 배치 실행 → offset 11 생성 (12월 데이터)
**2025년 2월 1일 03:00**: 배치 실행 → offset 12 (❌ 12개월 제한, 생성 안 함)

### 장점

1. **데이터 정확성**: 매달 말일까지 데이터가 완전히 쌓인 후 계산
2. **성능 최적화**: 이전 달 누적 재활용 (풀스캔 방지)
3. **점진적 축적**: 한 번에 1개씩만 생성 (DB 부하 분산)

## 6. 테스트 환경 특이사항

### 현재 설정: 매 1분마다 실행

**목적**: 과거 데이터를 빠르게 채우기 위함

**동작**:
- 3개월 전 더미 데이터 생성
- 배치 1분마다 실행
- offset 0, 1, 2, 3 순차적으로 4분 안에 생성
- offset 4~11은 아직 도래하지 않아 생성 안 됨

**주의**:
- 한 번에 여러 개가 생성되는 것처럼 보이지만, 실제로는 1분마다 1개씩 생성됨
- 프로덕션에서는 매달 1개씩 천천히 쌓임

## 7. 데이터 흐름 요약

```
┌─────────────────────────────────────────────────────────┐
│ 배치 스케줄러 (매 1분 / 매월 1일)                        │
└────────────────────┬────────────────────────────────────┘
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 1. 12개월 이내 시작한 캠페인 조회                        │
└────────────────────┬────────────────────────────────────┘
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 2. 각 캠페인마다 processActivityCohort() 호출            │
└────────────────────┬────────────────────────────────────┘
                     ▼
         ┌───────────────────────┐
         │ DB에서 lastOffset 조회│
         └───────────┬───────────┘
                     ▼
         ┌───────────────────────┐
         │ newOffset = last + 1  │
         └───────────┬───────────┘
                     ▼
         ┌───────────────────────┐
         │ 해당 월 도래했는지 확인│
         └───────────┬───────────┘
                     ▼
              ┌──────┴──────┐
              │ 아니오       │ 예
              ▼              ▼
         return null   ┌─────────────────┐
                       │ 코호트 고객 조회 │
                       └────────┬────────┘
                                ▼
                       ┌─────────────────┐
                       │offset 0?        │
                       └────┬─────┬──────┘
                        예  │     │ 아니오
                            ▼     ▼
                    ┌──────────┐ ┌──────────────────┐
                    │전체 계산 │ │이전 달 누적 재활용│
                    └─────┬────┘ └─────┬────────────┘
                          │            │
                          └──────┬─────┘
                                 ▼
                       ┌─────────────────┐
                       │ 재구매 분석      │
                       │(전체 구매 조회)  │
                       └────────┬────────┘
                                ▼
                       ┌─────────────────┐
                       │ LTVBatch 생성    │
                       │ INSERT 1개       │
                       └────────┬────────┘
                                ▼
                           [완료]
```

## 8. FAQ

### Q1: 왜 매번 1개씩만 생성하나요?
A: 증분 업데이트의 핵심입니다. 이전 달 누적 데이터를 재활용하여 성능을 최적화합니다.

### Q2: 과거 데이터가 누락되면 어떻게 되나요?
A: 순차적으로 채워집니다. offset 0이 없으면 0부터, 2가 없으면 2부터 생성됩니다.

### Q3: 왜 1분마다 실행되나요?
A: 테스트 환경이기 때문입니다. 프로덕션에서는 `"0 0 3 1 * ?"`로 변경하여 매월 1일 3시에만 실행됩니다.

### Q4: 재구매 분석은 왜 전체 조회하나요?
A: 재구매율, 평균 구매 빈도는 누적 지표라서 전체 구매 이력이 필요합니다. 하지만 코호트 고객 목록만 조회하므로 효율적입니다.

### Q5: 12개월 제한 이유는?
A: LTV 분석은 보통 1년 단위로 충분하며, 데이터 증가를 제어하기 위함입니다.

## 9. 성능 개선 효과

### 기존 방식 (제거된 calculateMonthlyStats)
```
매달 offset 0~11 전부 재계산 (UPSERT)
→ 100개 캠페인 × 12개월 = 1,200번 UPSERT
→ 8분 소요
```

### 개선 방식 (현재 calculateIncrementalStats)
```
매달 새로운 offset 1개만 INSERT
→ 100개 캠페인 × 1개월 = 100번 INSERT
→ 1.4분 소요 (82% 개선)
```

## 10. 코드 위치

- **스케줄러**: `CohortLtvBatchScheduler.java:23`
- **메인 로직**: `CohortLtvBatchService.java:39` (processMonthlyCohortStats)
- **offset 계산**: `CohortLtvBatchService.java:97-102`
- **날짜 범위**: `CohortLtvBatchService.java:246-247`
- **증분 로직**: `CohortLtvBatchService.java:255-291` (calculateIncrementalStats)
